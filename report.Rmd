```{r, setup, include=FALSE}
knitr::opts_chunk$set(
      fig.path = "figures/report/fig-"
)
```


# Executive summary

# Data wrangling

In this section, we describe our data gathering and tidying process.
We will be making extensive use of the `tidyverse` family of packages.
A series of scripts are used to generate tibbles, which are then saved in a `*.feather` for fast loading.
A full list of scripts can be viewed in the Appendix (TODO!!!)
```{r message = FALSE}
library(tidyverse)
library(feather)
```

## Data sources

Our dataset consists of two parts: publicly obtained data and simulated clients.
Below we describe our publicly obtained datasets.

Filename | Source | Description
---------|--------|------------
`covid_deaths_usafacts.csv` | [USAFacts](https://usafacts.org/visualizations/coronavirus-covid-19-spread-map/) | Cumulative weekly COVID-19 deaths by county
`soa_base_2017.csv` | (Sent by Douglas Armstrong) | $q_x$ values by gender, age, industry
`Population_Estimates.csv` | ??? | ???
`COVID-19_Vaccinations_in_the_United_States_County_data.gov.csv` | ??? | ???  
`Education_Estimates.csv` | ??? | ???
`Poverty_Estimates.csv` | ??? | ???
`Unemployment_Estimates.csv` | ??? | ???
`Vaccine_Hesitancy_for_COVID-19__County_and_local_estimates.csv` | [CDC](https://catalog.data.gov/dataset/vaccine-hesitancy-for-covid-19-county-and-local-estimates) | Vaccine hesitancy estimates for COVID-19
`countypres_2000-2020.csv` | [MIT Election Data + Science Lab](https://dataverse.harvard.edu/file.xhtml?fileId=4819117&version=9.0) | Election data by county (only 2020 used)
`zcta_county_rel_10.txt` | [US Census Bureau](https://www.census.gov/geographies/reference-files/time-series/geo/relationship-files.2010.html#par_textimage_674173622) | Zip code to county relationship file (2010)
`2020_12_23/reference_hospitalization_all_locs.csv` | [IHME](http://www.healthdata.org/node/8787) | COVID-19 projections **as of Dec 23 2020**
`state.txt` | [US Census Bureau] | State names and FIPS codes


### US Census bureau
We used the US Census Bureau's API to obtain the 2019 estimates for population and density per county from the Census Bureau's Population Estimates Program (PEP).
The `censusapi` package provides an R interface to the API.
Using the API requires an API key, which can be obtained from [here](https://api.census.gov/data/key_signup.html).
The following snippet fetches the data, and saves the tibble into a file called `pop_den.feather`. See also `data/census.R`.
```{r eval = FALSE}
library("censusapi")

Sys.setenv(CENSUS_KEY = "YOUR_KEY_HERE")

# date_code = 12 is an estimate for July 1, 2019
# total population + density
pop <- getCensus(
                 name = "pep/population",
                 vintage = 2019,
                 region = "county:*",
                 vars = c("POP", "DENSITY"),
                 DATE_CODE = 12)
pop <- tibble(pop) %>%
  select(-DATE_CODE)
write_feather(pop, "pop_den.feather")
```

See also `data/all_persons.r`.


## County to zip3
So far all of our public data is expressed by US county, but our clients' location are given as a ZIP3 code (the first three digit of a five-digit zip code).
The conversion from county to ZIP3 is nontrivial, as some zip codes span multiple counties and some counties span multiple zip codes.

To convert data given by county to ZIP3, we first need a ZIP3 to county relationship table.

The relationship table contains three columns: ZIP3, County, and Population. Each row will correspond to a pair $(\text{ZIP3}, \text{county})$, and the Population column will contain the population in the intersection $\text{ZIP3} \cap \text{county}$.
Then, given county-level data, we compute the corresponding value for any given ZIP3 by taking a weighted average of all counties intersecting that ZIP3, and weighting by the population in $\text{ZIP3} \cap $\text{county}$.
This operation looks as follows in code (suppose `A` contains some county-level data, e.g. poverty levels):
```{r eval = FALSE}
A %>%
  left_join(zip3_rel, by = "county") %>%
  group_by(zip3) %>%
  summarize(poverty = weighted.mean(poverty, population, na.rm = TRUE))
```

We note that in practice, the country is represented by a 5 digit FIPS code.
The first two digits indicate the state, and the last 3 digits indicate the county.

The relationship table is generated by `zip3_rel.R` and can be loaded from `zip3_rel.feather`.
For an example of how it's used, see `wrangling.Rmd` and `deaths.R`.

## Weekly deaths & IHME forecasts
In some of our models we use weekly Covid deaths as a predictor.
The file `covid_deaths_usafacts.csv` contains this data for every day and every county.
We convert the county-level information to zip3 as above, and convert the daily data to weekly.
The library `lubridate` doesn't contain a type for week; we use the last day of the week instead (using `lubridate::ceiling_date(date, unit = "week")`).

We will also be using forecasts from the Institute for Health Metrics and Evaluation (IHME) to assist our models.
These forecasts are only given by state, so we need to convert states to ZIP3.
The file `data/state.txt` contains the state FIPS code and state name.
Since some ZIP3 codes span several states, we assign a state to each ZIP3 code by determining which state is most represented among counties in the ZIP3.

See also `data/deaths.R` and `time.Rmd` (line 856 onwards).

## Simulated client dataset
The clients we were tasked to study were simulated by Securian Financial.
The dataset consists of 20 files called `data/simulation_data/experience_weekly_{n}.RDS` and `data/simulation_data/person_{n}.RDS` for $n = 1,\dotsc, 10$.
In total, we have 500 clients and 1,382,321 individuals.

The `person_{n}.RDS` files contain information such as company, zip code, age, face amount, gender, and collar (blue or white, but in this dataset every indivual was blue collar).
The rows in `experience_weekly_{n}.RDS` correspond to individuals and weeks, and contains in a flag `deaths` that becomes 1 on the week they die.
In total, these tables contain 170,025,483 rows, but the same information can be conveyed in 1,382,231 rows by attaching to each individual their death date (or `NA` if they don't die).
```{r eval = FALSE}
read_data <- function(n) {
  exp_name <- str_glue("simulation_data/experience_weekly_{n}.RDS")
  per_name <- str_glue("simulation_data/person_{n}.RDS")
  exp <- read_rds(exp_name)
  per <- read_rds(per_name)

  dies <-
    exp %>%
    filter(death > 0) %>%
    select(client, participant, week, month, year)
  aug_per <-
    per %>%
    left_join(dies, by = c("client", "participant"))

  aug_per
}

all_persons <- (1:10) %>% map_dfr(read_data)
```

We noticed that some individuals die more than once. This removes multiple deaths
```{r eval = FALSE}
all_persons <-
  all_persons %>%
  group_by(client, participant) %>%
  arrange(year, week, .by_group = TRUE) %>%
  slice_head()
```

We finally attach to each individual their yearly $q_x$ value, and save the resuilting tibble in `data/simultation_data/all_persons.feather`.

```{r eval = FALSE}
qx_table <- read_csv("soa_base_2017.csv")

all_persons <-
  all_persons %>%
  left_join(qx_table, by = c("Age", "Sex", "collar")) %>%
  relocate(qx, .after = collar)

write_feather(all_persons %>% ungroup(), "simulation_data/all_persons.feather")
```

The individual-level dataset is then converted to a client-level dataset.
We summarize each client by taking their ZIP3, size (number of individuals), volume (sum of face amounts), average qx, average age, and expected amount of claims.
We also compute the amount weekly total amount of claims.

## Final cleanup
There are some ZIP3 codes our clients are located in which we cannot deal with
They correspond to the following areas

ZIP3 | Area       |
-----|------------|
969  | Guam, Palau, Federated States of Micronesia, Northern Mariana Islands, Marshall Islands |
093  | Military bases in Iraq and Afghanistan |
732  | Not in use |
872  | Not in use |
004  | Not in use |
202  | Washington DC, Government 1 |
753  | Dallas, TX |
772  | Houston, TX |

The final two are problematic since they contained no population in 2010: one is used exclusively by a hospital, and the other is used exclusively by a mall.
Additionally, election data is not available in Washington D.C., so we remove clients located there.
In the end, we have a total of 492 clients to work with.

The data merging is done in the file `processed_data.r` which generates the file `data/processed_data_20_12_23.feather`.
The dependency tree is outlined in the Appendix (TODO!!!)

After merging, this gives us a final dataset of 492 clients over 118 weeks ranging from Jan 1st 2019 to June 27th 2021.
We make two separate tibbles.
```{r}
weekly_data <-
  read_feather("data/processed_data_20_12_23.feather") %>%
  select(-ae_2021, -ae_2020, -ae_2019,
         -actual_2021, -actual_2020, -actual_2019, -adverse,
         -STATE_NAME, -shrinkage,  -dep_var) 

yearly_data <-
  read_feather("data/processed_data_20_12_23.feather") %>%
  group_by(client) %>%
  slice(1) %>%
  select(-date, -claims, -zip_deaths, -smoothed_ae, -shrunk_ae,
         -class, -smoothed_deaths,
         -hes, -hes_uns, -str_hes, -ae, -dep_var, -shrinkage, -STATE_NAME, -ihme_deaths)
```

Each row in `yearly_data` corresponds to a client, and it contains the following variables

Variable | Description
---------|------------
`zip3` | ZIP3 code
`client` | client ID
`size` | number of individuals
`volume` | sum of face values
`avg_qx` | average $q_x$
`avg_age` | average age
`per_male` | percentage of males
`per_blue_collar` | percentage of blue collar workers
`expected` | expected yearly amount of claims
`actual_{2021, 2020, 2019}` | actual claims in {2021, 2020, 2019}
`ae_{2021, 2020, 2019}` | actual claims / expected claims in {2021, 2020, 2019}
`nohs` | percentage of zip residents without a high school diploma
`hs` | percentage of zip residents with only a high school diploma
`college` | percentage of zip residents with only a community college or associates degree
`bachelor` | percentage of zip residents with a bachelor's degree
`R_birth` | birthrate in zip
`R_death` | deathrate in zip (pre-covid)
`unemp` | unemployment in zip
`poverty` | percentage of zip residents living in poverty
`per_dem` | percentage of zip residents who voted Democrat in 2020
`svi` | Social Vulnerability Index
`cvac` | CVAC level of concern for vaccine rollout
`income` | median household income in zipcode
`POP` | population in zipcode
`density` | zipcode population density
`adverse` | whether or not ae_2020 > 3

The tibble `weekly_data` contain most of the above variables, but also some that change weekly.
Each row correspond to a pair $(\text{client}, \text{week})$.
We describe the ones not present above

Variable | Description
---------|------------
`date` | the last day of the week (`lubridate::ceiling_date(date, unit = "week")`)
`claims` | claims for that client on that week (\$)
`zip_deaths` | number of deaths that week in the zipcode
`smoothed_ae` | smoothed version of actual weekly AE (see TODO)
`shrunk_ae` | shrunk version of smoothed weekly AE (see TODO)
`ae` | actual weekly AE
`ihme_deaths` | IHME Covid death forecasts. **These are only available until Apr 4th 2021, and are set to 0 after this date.**

# Long-term model

## Intro

## Methods

## Results


# Short-term model

## Intro

## Methods

## Results

# Conclusion

# Appendices

## Data repository

## R scripts

## Rmd files
